哈希表是一种 [key-value] 的数据结构，我们可以通过 key 快速找到 value（反之不然）
其核心就是通过对 key 映射到一个特定的内存空间。

我们先想象一个数组，下标就是 key ，数组内存的东西就是 value. 
key通过作为数组首地址的偏移来确定唯一的内存空间，这就是一种映射方式。

但实践中，key可能千奇百怪：可能是很大很大的数，可能是字符串等等。我们就需要确定一种方式来映射了。这个映射函数就是哈希函数。

一般来说，哈希函数是对某个质数取模，但难以避免的会出现不同的key哈希后结果一样的情况，这被称为冲突。为解决冲突主要用两种思路：
- 拉链法：在冲突的位置创建一个链表，所有冲突的值都放里边
- 闭散列法：从冲突的位置开始，一直向下一寻找，直到找到空的位置把value放进去
（根据某些神秘的数学原理，模数设置为小于存储总空间的最大质数能最大程度避免冲突），

```cpp
struct hashTable
{
    using ll = long long;
    const int SIZE = 1e5;
    const int M = 1e5 -3;
    vector<list<pair<ll, ll>>> ware;
    //pair的第一项为key,第二项为value
    //list用于实现拉链法

    hashTable() : ware(SIZE) {}
    //构造函数，给ware容器分配SIZE

    void add(ll key, ll value) {
        ware[hash(key)].push_back(make_pair(key, value));
    }
    //添加键值对

    inline int hash(ll key) {
        return (key % M + M) % M;
    }
    //哈希函数，核心在于对小于SIZE的最大质数取模可以最大程度避免冲突
    
    ll getValue(ll key) {
        if (ware[hash(key)].empty()) return -1;
        else for (auto i : ware[hash(key)]) {
            if (i.first == key) return i.second;
        }
        return -1;
    }
    //首先判断key所指位置链表是否为空
    //然后遍历链表，直到找到key正确的项

    void modify(ll key, ll value) {
        for (auto i : ware[hash(key)]) {
            if (i.first == key) i.second = value;
        }
        return;
    }
    //与getvalue很像，先找到key原本的value位置，然后修改之
};
```
上面是拉链法的一个实现。





